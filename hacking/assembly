ASSEMBLY

OBJDUMP

objdump -> To view assembly of a binary file

objdump -D a.out | grep -A20 main.: -> dump assmebly from binary file, grep for main.: and show first 20 lines after that line

Intel and AT&T syntax. AT&T uses % and $. With src, dest. Intel forgoes the % and $, and uses dest,src formatting

objdump -M intel -D a.out -> show assembly in Intel syntax.

GuB

gdb -> debugger for C/C++. Can set breakpoints and see the values in registers

gdb -q ./a.out 

(gdb) break main
Breakpoint 1 at 0x804837a

info registers -> in gdb. Show the registers and the values inside of them. 

Can also set to Intel or AT&T syntax in DB.

set adisasembly intel
set dis intel

Can configure GDB by editing file .gdbinit in home directory. 

REGISTERS

EAX, ECX, EBX, EDX -> general purpose registers. Accumulator, Counter, Base, Data registers. Used for variety of purposes but mainly act as temp variables for CPU when it is executing instructions. 

ESP, EBP, ESI, EDI -> other general purpose registers. Stack Pointer, Base Pointer, Source Index, Destination Index. Fist two are pointers because they store 32 bit addressess. Fairly important to program execution and memory management. Last two are also technically pointers which are commonly used to point to the source and destination when data needs to be read from or writter to.

EIP - Instruction Pointer, points to the current instruction the processor is reading. Like running finger while reading. 

EFLAGS - several bit flags that are used for comparisons and memory segmentatins. 

ASSEMBLY

Intel

operation <dest, src>

AT&T

operation <src, dest>

Destination and src values will either be a register, a memory address, or a value. 

mov -> will move a value from the src to the dest
sub -> will subtract
inc -> will increment

Also operations used to control the flow of execution

cmp -> compare values. 

Basically any operation beginning with j is used to jump to different parts of code. 

jle -> jump if less than or equal to (referring to previous copmarison). Jump to instruction at address
jmp -> jump to address

Use the -g flag with gcc when compiling to include extra debugging information which will give GDB access to the source code. 

gcc -g firstprog.c

gdb -q ./a.out

Can read source code by calling list command in gdb

(gdb) list
1	#include <stdio.h>
2	
3	int main()
4	{
5	  int i;
6	  for(i=0; i < 10; i++)
7	  {
8	    printf("Hello World!\n");
9	  }
10	}

To disassemble specific function

(gdb) disassemble main
Dump of assembler code for function main:
   0x00000000000006a0 <+0>:	push   %rbp
   0x00000000000006a1 <+1>:	mov    %rsp,%rbp
   0x00000000000006a4 <+4>:	sub    $0x10,%rsp
   0x00000000000006a8 <+8>:	movl   $0x0,-0x4(%rbp)
   0x00000000000006af <+15>:	jmp    0x6c1 <main+33>
   0x00000000000006b1 <+17>:	lea    0x9c(%rip),%rdi        # 0x754
   0x00000000000006b8 <+24>:	callq  0x560
   0x00000000000006bd <+29>:	addl   $0x1,-0x4(%rbp)
   0x00000000000006c1 <+33>:	cmpl   $0x9,-0x4(%rbp)
   0x00000000000006c5 <+37>:	jle    0x6b1 <main+17>
   0x00000000000006c7 <+39>:	mov    $0x0,%eax
   0x00000000000006cc <+44>:	leaveq 
   0x00000000000006cd <+45>:	retq   
End of assembler dump.

(gdb) break main
Breakpoint 1 at 0x6a8: file firstprog.c, line 6.
(gdb) run
6	  for(i=0; i < 10; i++)
(gdb) info register eip
Invalid register `eip'
(gdb) info register rip
rip            0x5555555546a8	0x5555555546a8 <main+8>
(gdb) info register
rax            0x5555555546a0	93824992233120
rbx            0x0	0
rcx            0x0	0
rdx            0x7fffffffe198	140737488347544
rsi            0x7fffffffe188	140737488347528
rdi            0x1	1
rbp            0x7fffffffe0a0	0x7fffffffe0a0
rsp            0x7fffffffe090	0x7fffffffe090
r8             0x555555554740	93824992233280
r9             0x7ffff7de7dd0	140737351941584
r10            0x4	4
r11            0x1	1
r12            0x555555554570	93824992232816
r13            0x7fffffffe180	140737488347520
r14            0x0	0
r15            0x0	0
rip            0x5555555546a8	0x5555555546a8 <main+8>
---Type <return> to continue, or q <return> to quit---
eflags         0x206	[ PF IF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0

Notice that EIP contains memory address that points to an instruction in main() function disassemly. Instructions before this are known as *function prologue*

function prologue -> generated by the compiler to set up memory for the rest of the main() function's local variables. Part of the reason variables need to be declared in C is to aid construction of this section of code

GDB

x -> examine memory. Running program is mostly just a processor and segments of memory. Can be used to look at a certain address of memory in a variety of ways. Command expects two arguments when used: the location in memory to examine and how to display that memory.

Display format alsu uses a single-letter shorthand, which is optionally preceded by a count of how many items to examine. 

o -> display in octal
x -> display in hex
u -> display in unsigned, standard base-10 decimal
t -> display in binary

i r eip -> info register eip

Can reference registers with $ symbol

(gdb) x/o 0x5555555546a8
0x5555555546a8 <main+8>:	077042707
(gdb) x/o $rip
0x5555555546a8 <main+8>:	077042707
(gdb) x/x $rip
0x5555555546a8 <main+8>:	0x00fc45c7
(gdb) x/u $rip
0x5555555546a8 <main+8>:	16532935
(gdb) x/t $rip
0x5555555546a8 <main+8>:	00000000111111000100010111000111

Number can also be prpended to the format of the examine command to examine multiple units at the target address

(gdb) x/2x $rip
0x5555555546a8 <main+8>:	0x00fc45c7	0xeb000000
(gdb) x/12x $rip
0x5555555546a8 <main+8>:	0x00fc45c7	0xeb000000	0x3d8d4810	0x0000009c
0x5555555546b8 <main+24>:	0xfffea3e8	0xfc4583ff	0xfc7d8301	0xb8ea7e09
0x5555555546c8 <main+40>:	0x00000000	0x9066c3c9	0x56415741	0x41ff8941

Default size of a single unit is a four-byte unit called a word. Size of the display units for the examine command can be changed by adding a size letter to the end of the format

b -> a single byte
h -> A halfword, which is 2 bytes in size
w -> A word, which is 4 bytes in size
g -> A giant, which is 8 bytes in size

Sometimes word also refers to 2 byte values. 

In this case, double word DWORD refers to a 4 byte value. 

short - halfword. 2 byte value. 

Following shows memory displayed in various sizes

(gdb) x/8xb $rip
0x5555555546a8 <main+8>:	0xc7	0x45	0xfc	0x00	0x00	0x00	0x00	0xeb
(gdb) x/8xh $rip
0x5555555546a8 <main+8>:	0x45c7	0x00fc	0x0000	0xeb00	0x4810	0x3d8d	0x009c	0x0000
(gdb) x/8xw $rip
0x5555555546a8 <main+8>:	0x00fc45c7	0xeb000000	0x3d8d4810	0x0000009c
0x5555555546b8 <main+24>:	0xfffea3e8	0xfc4583ff	0xfc7d8301	0xb8ea7e09
(gdb) 

May notice something odd. First examine shows the first two bytes to be 0xc7 and 0x45, but when a halfword is examine at same memoery address, the value 0x45c7 is shown with bytes reversed. Same can be scene when full 4 byte word is shown as 0x00fc45c7. When when first 4 bytes are shown byte by byte they are in order of 0xc7, 0x45, 0xfc, 0x00. 

x86 values are stored in little-endian order, means the least significant byte is storedfirst. If bytes are to be interpreted as a single value, the bytes must be used in reverse order. 

GDB is smart enough to know how values are stored. 

(gdb) x/4xb $rip
0x5555555546a8 <main+8>:	0xc7	0x45	0xfc	0x00
(gdb) x/4ub $rip
0x5555555546a8 <main+8>:	199	69	252	0
(gdb) x/1xw $rip
0x5555555546a8 <main+8>:	0x00fc45c7
(gdb) x/1uw $rip
0x5555555546a8 <main+8>:	16532935

199 * (256^3) + 69*(256^2) + 252*(256^1) + 0*(256^0)
3343252480
0*(256^3) + 252*(256^2) + 69*(256^1) + 199*(256^0)

To get value of a byte: For each hex digit, multiple by 16 to a power
To get value of a byte, multiply decimal value by 256 to a power
To get value of a word, multiply decimal value of each byte by 256 to a power

Byte order of a given architecture is an important detail to be aware of. 

GDB examine command also accepts the format letter i, short for instruction, to display the memory as disassembled assembly language instructions

(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/david/Dropbox/test/hacking/booksrc/a.out 

Breakpoint 1, main () at firstprog.c:6
6	  for(i=0; i < 10; i++)
(gdb) i r $rip
rip            0x5555555546a8	0x5555555546a8 <main+8>
(gdb) x/i $rip
=> 0x5555555546a8 <main+8>:	movl   $0x0,-0x4(%rbp)
(gdb) x/3i $rip
=> 0x5555555546a8 <main+8>:	movl   $0x0,-0x4(%rbp)
   0x5555555546af <main+15>:	jmp    0x5555555546c1 <main+33>
   0x5555555546b1 <main+17>:	lea    0x9c(%rip),%rdi        # 0x555555554754
(gdb) x/7xb $rip
0x5555555546a8 <main+8>:	0xc7	0x45	0xfc	0x00	0x00	0x00	0x00
(gdb) x/i $rip
=> 0x5555555546a8 <main+8>:	movl   $0x0,-0x4(%rbp)

Disassembly shows that 7 bytes EIP is pointint to are actually machine language for corresponding assembly instrucction. 

8048384:	c7 45 fc 00 00 00 00	mov		DWORD PTR [ebp-4],0x0

Assembly instruction moves value of 0 into memory located at address stored in EBP register minus 4. This is where C variable i is stored in memory; i was declared as an integer that uses 4 bytes of memory on x86 processor. Basically, command will zero out the variable i for the for loop. If that memory is examined right now, it will contain nothing but random garbage. Memory at this location can be examined in several ways

(gdb) i r ebp
ebp		0xbffff808		0xbffff808
(gdb) x/4xb $ebp-4
0xbffff804:		0xc0	0x83	0x04	0x08
(gdb) x/4xb: 0xbffff804
0xbffff804:		0xc0	0x83	0x04	0x08
(gdb) print $ebp-4
$1 = (void *) 0xbffff804
(gdb) x/4xb $1
0xbffff804:		0xc0	0x83	0x04	0x08
(gdb) x/xw $1
0xbffff804:		0x080483c0

GDB. print command stores result in temporary variable in debugger. Variable can be used later to quickly reaccess a particular location in memory. 

nexti -> GDB command which means next instruction. Processor will read instruction at EIP, execute it, and advance EIP to next instruction.a

(gdb) nexti
0x0804838b	6	for(i=0; i < 10; i++)
(gdb) x/4xb $1
0xbffff804:		0x00	0x00	0x00	0x00
(gdb) x/dw $1
0xbffff804:		0
(gdb) i r eip
eip		0x804838b	0x804838b <main+23>
(gdb) x/i $eip
0x804838b <main+23>:	cmp		DWORD PTR [ebp-4],0x9
(gdb)

Now examine next instructions.

(gdb) x/10i $eip
0x804838b <main+23>:	cmp		DWORD PTR [ebp-4], 0x9
0x804838f <main+27>:	jle		0x8048393 <main+31>
0x8048391 <main+29>:	jmp		0x80483a6 <main+50>
0x8048393 <main+31>:	mov		DWORD PTR [esp], 0x8048484
0x804839a <main+38>:	call	0x80482a0 <printf@plt>
0x804839f <main+43>:	lea		eax,[ebp-4]
0x80483a2 <main+46>:	inc		DWORD PTR [eax]
0x80483a4 <main+48>:	jmp		0x804838b <main+23>
0x80483a6 <main+50>:	leave
0x80483a7 <main+51>:	ret
(gdb)

cmp is compare instruction, which will compare the memory used by the C variable i with the value 9. 

The next instruction, jle, stands for jump if less than or equal to. It uses the results of the previous comparison (which are actually stored in the EFLAGS register) to jump to a different part of the code if the destination of the previous comparison operation is less tan or equal to the source. In this case, jump to 0x8048393 if value stored in memory for the C variable i is <= 9. If this is not the cast, EIP will jump to next instruction which is an unconditional jump instruction. Will jump to 0x80483a6

cmp, jle, jmp -> combine to create if-then-else structure. If i <= 9, jump to instruction 0x8048393, else jump to instruction 0x80483a6

(gdb) nexti
0x0804838f		6		for(i=0; i < 10; i++)
(gdb) x/i $eip
0x804838f <main+27>:	jle		0x8048393 <main+31>
(gdb) nexti
8		printf("Hello, world!\n");
(gdb) i r eip
eip		0x8048393		0x8048393 <main+31>
(gdb) x/2i $eip
0x8048393 <main+31>:	mov		DWORD PTR [esp],0x8048484
0x804839a <main+38>:	call	0x80482a0 <printf@plt>
(gdb)

mov instruction will write the address 0x8048484 into the memory address contained in ESP register.

But what is ESP pointing to?

(gdb) i r esp
esp		0xbffff800	0xbffff800
(gdb)

One way to find out

(gdb) x/2xw 0x8048484
0x8048484:		0x6c6c6548		0x6f57206f
(gdb) x/6xb 0x8048484
0x8048484:		0x48	0x65	0x6c	0x6c	0x6f	0x20
(gdb) x/6ub 0x8048484
0x8048484:		72		101		108		108		111		32
(gdb)

Trained eye might notice something about memory here, in particular the range of bytes. These bytes fall wihtin the printable ASCII range.

ASCII - agreed upon standard that maps all characters on keyboard (and some that aren't) to fixed numbers. Typing ascii on Unix systems brings up table

GDB contains provisions for looking at this type of memory.

c -> format character can be used to automatically look up a byte on ASCII table
s -> will display an entire string of character data

(gdb) x/6cb 0x8048484
0x8048484:		72 'H' 101 'e' 108 'l' 108 'l' 111 'o' 32 ' '
(gdb) x/s 0x8048484
0x8048484:		"Hello, world!\n"
(gdb)

"Hello, world\n" is string stored in memory address 0x8048484. Is the argument for the printf() function, which indiates that moving address of this string to address stored in ESP is essential to this function. 

(gdb) x/2i $eip
0x8048393 <main+31>:	mov		DWORD PTR [esp],0x8048484
0x804839a <main+38>:	call	0x80482a0 <printf@plt>
(gdb) x/xw $esp
0xbffff800:		0xb8000ce0
(gdb) nexti
0x0804839a		8		printf("Hello, world!\n");
(gdb) x/xw $esp
0xbffff800:		0x08048484
(gdb)

Call nexti to execute call to printf()

Can use gdb to examine next two instructions:

(gdb) x/2i $eip
0x804839f <main+43>:	lea		eax,[ebp-4]
0x80483a2 <main+46>:	inc		DWORD PTR [eax]
(gdb)

Increments variable i by 1.

lea -> Load Effective Address. Loads address of EBP-4 into eax register. 

(gdb) x/i $eip
0x804839f <main+43>:	lea		eax,[ebp-4]
(gdb) print $ebp - 4
$2 = (void *) 0xbffff804
(gdb) x/x $2
0xbffff804:		0x00000000
(gdb) i r eax
eax		0xd		13
(gdb) nexti
0x080483a2		6	for(i=0; i < 10; i++)
(gdb) i r eax
eax		0xbffff804		-1073743868
(gdb) x/xw $eax
0xbffff804:		0x00000000
(gdb) x/dw $eax
0xbffff804:		0
(gdb)

inc -> increments value found at this address by 1. 

(gdb) x/i $eip
0x80483a2 <main+46>:	inc		DWORD PTR [eax]
(gdb) x/dw $eax
0xbffff804:		0
(gdb) nexti
0x080483a4		6		for(i=0; i < 10; i++)
(gdb) x/dw $eax
0xbffff804:		1
(gdb)

Can also set breaks in GDB by line number or by function call

(gdb) break 6
(gdb) break strcpy
(gdb) break 8

If you look at EIP for a called function loaded from a library, you will see that the address EIP points to a different address than those in main. Because the instruction is located elsewhere in the loaded library. 

EIP is able to travel from the main code to the strcpy() code and back again. 

Each time a function is called, a record is kept on a data structure called the stack. The stack lets EIP return through long chains of function calls. 

bt -> GDB command that can be used to backstrace the stack.

(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/reader/booksrc/char_array2
Error in re-setting breakpoint 4:
Function "strcpy" not defined.
Breakpoint 1, main () at char_array2.c:7
7		strcpy(str_a, "Hello, world!\n");
(gdb) bt
#0 main () at char_array2.c:7
(gdb) cont
Continuing.
Breakpoint 4, 0xb7f076f4 in strcpy () from /lib/tls/i686/cmov/libc.so.6
(gdb) bt
#0 0xb7f076f4 in strcpy () from /lib/tls/i686/cmov/libc.so.6
#1 0x080483d7 in main () at char_array2.c:7
(gdb) cont
Continuing.
Breakpoint 3, main () at char_array2.c:8
8		printf(str_a);
(gdb) bt
#0 main () at char_array2.c:8
(gdb)

May notice that strcpy function is at a different memory address on the second run. This is due to an exploit protection method that is turned on by default in Linux kernal since 2.6.11. 


Twos Complement

When negative value in two's complement is added to a prositive number of the same magnitude, then the result will be 0. This is done by first writing the positive number in binary, then inverting all the bits and finally adding 1. 

Works and allows negative numbers to be added in combination with positive numbers using simple binary adders. 
Pointers

Pointer size depends on architecture of system. 32bit architectures have 32bit pointers. 

Can examine pointers in GDB

reader@hacking:~/booksrc $ gcc -g -o pointer pointer.c
reader@hacking:~/booksrc $ gdb -q ./pointer
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) list
1 #include <stdio.h>
2 #include <string.h>
3
4 int main() {
5 char str_a[20]; // A 20-element character array
6 char *pointer; // A pointer, meant for a character array
7 char *pointer2; // And yet another one
8
9 strcpy(str_a, "Hello, world!\n");
10 pointer = str_a; // Set the first pointer to the start of the array.
(gdb)
11 printf(pointer);
12
13 pointer2 = pointer + 2; // Set the second one 2 bytes further in.
14 printf(pointer2); // Print it.
15 strcpy(pointer2, "y you guys!\n"); // Copy into that spot.
16 printf(pointer); // Print again.
17 }
(gdb) break 11
Breakpoint 1 at 0x80483dd: file pointer.c, line 11.
(gdb) run
Starting program: /home/reader/booksrc/pointer
Breakpoint 1, main () at pointer.c:11
11	printf(pointer);
(gdb) x/xw pointer
0xbffff7e0:		0x6c6c6548
(gdb) x/s pointer
0xbffff7e0:		"Hello, world!\n"
(gdb)

Can use & operator in both GDB and in C

(gdb) x/xw &pointer
0x7fffffffe070:	0xffffe080
(gdb) print &pointer
$1 = (char **) 0x7fffffffe070
(gdb) print pointer
$2 = 0x7fffffffe080 "Hello World\n"
(gdb) 

Can use * dereference symbol in GDB

(gdb) print pointer
$2 = 0x7fffffffe080 "Hello World\n"
(gdb) print *pointer
$3 = 72 'H'

Format Strings

%n -> takes a pointer. Prints number of bytes that have been written so far into that memory address. 

Pointer Arithmetic

Pointers increment based on the size of their type but can point to data of a different type (though this will throw a compiler warning). A char pointer will only increment by 1 byte. A int pointer will increment by 4. Based on system arhcitecture. 

Segmentation Fault

Memory is split into segments. Some memory addresses aren' twithin the boundaries of the memory segments the program is given access to. When program attempts to access an address that is out of bounds, it will crash in a segmentation fault. 

Stack Frame

Backtrace show record of each function call on the stack. Also shows nested function calls by looking at records kept on the stack. 

Each time a function is called, a record called a *stack frame* is put on the stack. Each line in the backtrace corresponds to a stack frame. Each stack frame also contains the local variables for that context. 

bt full -> GDB command that shows local variables in each stack frame.

Static - local to a particular function context but remains intact between function calls. Only initialized  once. 

static - varibles are basically global but are local within a particular functional context. So they can have the same name as a static variable somewhere else. They actually represent two different locatoins in memory. 

MEMORY SEGMENTATION

Compiled program's memory is divided into 5 segments:
1. text
2. data
3. bss
4. heap
5. stack

Each segment represents a special portion of memory that is set aside for a certain purpose

text segment (code segment_ => where the assembled machine language instructions of the program are located. Execution of instructions in this segment is nonlinear. As a program executes, the EIP is set to the first instruction in the text segment. 

Processor follows an execution loop:
1. Reads the instruciton that EIP is pointing to
2. Adds the byte length of the instruction to EIP
3. Executes the instruction that was read in step 1
4. Goes back to step 1

Write permission is disabled in tet segment. Not used to store variables, only code. 

Prevents people from modifying the program code. Any attempt to write to this segment of memory will cause the program to alert the user. Another advantage is that it can be shared among different copies of the program, allowing multiple executions of the program at the same time without any problems. Also, this memory segment has a fixed size since nothing ever changes. 

data segment - filled with the initialized global and static variables

bss -> filled with uninitialized global and static variables

Alhtough these segments are writeable, they also have a fixed size. Global and static variables persist, in part because they are stored in their own memory segments. 

heap segment -> Segment of memory a programmer can directly control. Blocks of meomry in this segment can be allocated and used for whatever the programmer might need. Can grow larger or smaller as needed. All memory within the heap is managed by allocator and deallocator algorithms, which respectively reserve a region of memory in the heap for use and remove reservations to allow that portion of memory to be reused for later reservations. The growth of the heap moves downward toward higher memory addresses. 

stack segment -> also has variable size and is used as a temporary scratch pad to store local functoin variables and context during function calls. What GDB's bt command looks at.

When a program calls a function, that function will have its own set of passed variables, and the function's code will be at a different memory location in the text (or code) segment. Since the context and the EIP must change when a function is called, the stack is used to remember all of the passed variables, the location of the EIP should return to after the function is finished, and all the local variables used by that function. 

This informatio nis stored together on the stack in what is collectively called a stack frame. A stack contains many stack frames. 

ESP register is used to keep track of the address of the end of the stack. Which is constantly changing as items are pushed and popped off it. 

As the stack changes in size, it grows upward in a visual listing of memory, toward lower memory addresses. 

When a function is called, several things are pushed to the stack together in a stack frame:

The EBP register (aka the frame pointer (FP) or local base (LB) pointer) is used to reference local function variables in the current stack frame. Each stack frame contains the parameters to the function, its local variables, and two pointers that are necessary to put things back the way they were: the saved frame pointer (SFP) and the return address. The SFP is used to restore EBP to its previous value, and the return address is used to restore EIP to the next instruction found after the function call. This restores the functional context of the previous stack frame.  

stack_example.c

function prologue -> the first instructions of a function. They save the frame pointer on the stack, and the ysave stack memory for the local function variables. Sometimes, will handle some stack alignment as well. Exact instructions vary depending on compiler and compiler options. 

reader@hacking:~/booksrc $ gcc -g stack_example.c
reader@hacking:~/booksrc $ gdb -q ./a.out
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) disass main
Dump of assembler code for function main():
0x08048357 <main+0>:	push	ebp
0x08048358 <main+1>:	mov		ebp,esp
0x0804835a <main+3>:	sub		esp,0x18
0x0804835d <main+6>:	and		esp,0xfffffff0
0x08048360 <main+9>:	mov		eax,0x0
0x08048365 <main+14>:	sub		esp,eax
0x08048367 <main+16>:	mov		DWORD PTR [esp+12],0x4
0x0804836f <main+24>:	mov		DWORD PTR [esp+8],0x3
0x08048377 <main+32>:	mov		DWORD PTR [esp+4],0x2
0x0804837f <main+40>:	mov		DWORD PTR [esp],0x1
0x08048386 <main+47>:	call	0x8048344 <test_function>
0x0804838b <main+52>:	leave	
0x0804838c <main+53>:	ret
End of assembler dump
(gdb) disass test_function()
Dump of assembler code for function test_function:
0x08048344 <test_function+0>:	push	ebp
0x08048345 <test_function+1>:	mov		ebp,esp
0x08048347 <test_function+3>:	sub		esp,0x28
0x0804834a <test_function+6>:	mov		DWORD PTR [ebp-12],0x7a69
0x08048351 <test_function+13>: 	mov		BYTE PTR [ebp-40],0x41
0x08048355 <test_function+17>: 	leave
0x08048356 <test_function+18>: 	ret
End of assembler dump
(gdb)

When test_function is called from main() function, the various values are pushed to the stack to create the start of the stack frame as follows. 

When test_function is called, the function arguments are pushed onto the stack in reverse order (since it is FILO). 

Next, when the assembly call instruction is executed, the return address is pushed onto the stack and execution flow jumps to the start of test_function at 0x08048344. In this case, return address points to the leave instruction in main() at 0x0804838b

Call instruction both stores the return address on the stack and jumps EIP to the beginning of test_function(), so test_function9)'s function prologue instructions finish building the stack frame. In this step, the curent value of EBP is pushed to the stack. this value is called the saved fram pointer (SFP) and is later used to restore EBP back to its original state. Current value of ESP is then copied into EBP to set the new frame pointer. The frame pointer is used to reference the local variables of a function by substracting from ESP.

Pg 73 Stack Example

Old frame pointer is stored next to old stack pointer. new stack pointer is raised for the amount of space needed. The stack pointer moves up to the very end(beginning) of the stack. The base pointer points to where the stack ends, the address after the highest address on the stack. Probably holds old stack pointer and return address under it. 

Heap and Stack toward each other

Can see memory segmentation with global and static variables, initialized and uninitialized. 

memory.segments.c

global and static initialized variables will have the lowest addresses as they are in the data segment. Uninitialized global and static variables will have the next highest since they are stored in the bss segment. Sinceboth of these segments have a fixed size after compilation, there is little wasted space and the addresses aren't very far apart. 

Heap segment is located just below the bss segment. 

heap_example.c

Heap grows download.

If allocate 50 bytes of memory, and then allocate more memory, you will see that as you allocate new memory, they get higher addresses. Even if you free previously allocated memory, new data may get higher addresses.

However, if you allocate more memory in the beginning (say 100 bytes) and free it, then later allocated memory may claim the freed space

Permissions

chmod 731 simplenote.c 

Gives user rwx, group rw, and other x permissions

chmod ugo-wx simplenote.c
Removes wx permissions from user, group, and other

chmod u+w simplenote.c
Adds w permission to user

User IDs

Every user on Unix system has a unique user ID number. 

id <user> -> displays the user ids for that user

id david
uid=1000(david) gid=1000(david) groups=1000(david),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),118(lpadmin),128(sambashare)

id root
uid=0(root) gid=0(root) groups=0(root)

Root use rwith user ID 0.

su -> switch to different user

sudo su jose
sudo su reader

May be a time for multiple users to need access to certain portions of the same file.

/etc/passwd -> file contains account information for every user on the system, including eac user's default login shell. 

chsh -> allows user to change his or her own login shell. Program needs to be able to make changes to /etc/passwd file but only on the line that contains the current user's account 

Solution to this poblem is the setuid permission

setuid -> additional file permission bit that can be set using chmod. When a program with this flag is executed, it runs as the user ID of the file's owner. 

reader@hacking:~/booksrc $ which chsh
/usr/bin/chsh
reader@hacking:~/booksrc $ ls -l /usr/bin/chsh /etc/passwd
-rw-r--r-- 1 root root 1424 2007-09-06 21:05 /etc/passwd
-rwsr-xr-x 1 root root 23920 2006-12-19 20:35 /usr/bin/chsh
reader@hacking:~/booksrc $

chsh has the setuid flag set, indicated by an s in the ls output. 

Since file is owned by root and has setuid permission set, the program will run as the root user when any user runs this program. 

The /etc/passwd file is owned by root and only allows owner to write to it. 

Program logic in chsh is deisnged to only allow writing tohe line in /etc/passwd that corresponds to the user running the program, even though the program is effectively running as root.

Means the running program has both a real user ID and an effective user ID.

getuid() -> get real user id. id of user running program
geteuid() -> get effective user id. id of user if s bit is active. owner of the program being executed

#include <stdio.h>
int main() {
printf("real uid: %d\n", getuid());
printf("effective uid: %d\n", geteuid());
}

reader@hacking:~/booksrc $ gcc -o uid_demo uid_demo.c
reader@hacking:~/booksrc $ ls -l uid_demo
-rwxr-xr-x 1 reader reader 6825 2007-09-07 05:32 uid_demo
reader@hacking:~/booksrc $ ./uid_demo
real uid: 999
effective uid: 999
reader@hacking:~/booksrc $ sudo chown root:root ./uid_demo
reader@hacking:~/booksrc $ ls -l uid_demo
-rwxr-xr-x 1 root root 6825 2007-09-07 05:32 uid_demo
reader@hacking:~/booksrc $ ./uid_demo
real uid: 999
effective uid: 999
reader@hacking:~/booksrc $

In output, noth users are 999 since user ID is reader.

sudo command used with chown to change owner and group of uid_demo to root. 

Program can still be executed since it has x permission for other, and it shows both IDs remain 999, since that it still id of user

reader@hacking:~/booksrc $ chmod u+s ./uid_demo
chmod: changing permissions of `./uid_demo': Operation not permitted
reader@hacking:~/booksrc $ sudo chmod u+s ./uid_demo
reader@hacking:~/booksrc $ ls -l uid_demo
-rwsr-xr-x 1 root root 6825 2007-09-07 05:32 uid_demo
reader@hacking:~/booksrc $ ./uid_demo
real uid: 999
effective uid: 0
reader@hacking:~/booksrc $

Now after giving program s permission, the program is effectively run as the root user. So can change files in system. 

Now can create a new notetaker.c program that prints the real user ID before a note written to /var/notes.

notetaker.c

reader@hacking:~/booksrc $ gcc -o notetaker notetaker.c
reader@hacking:~/booksrc $ sudo chown root:root ./notetaker
reader@hacking:~/booksrc $ sudo chmod u+s ./notetaker
reader@hacking:~/booksrc $ ls -l ./notetaker
-rwsr-xr-x 1 root root 9015 2007-09-07 05:48 ./notetaker
reader@hacking:~/booksrc $ ./notetaker "this is a test of multiuser notes"
[DEBUG] buffer
@ 0x804a008: 'this is a test of multiuser notes'
[DEBUG] datafile @ 0x804a070: '/var/notes'
[DEBUG] file descriptor is 3
Note has been saved.
reader@hacking:~/booksrc $ ls -l /var/notes
-rw------- 1 root reader 39 2007-09-07 05:49 /var/notes
reader@hacking:~/booksrc $

Compile notetake and change it to be owned by root, and the setuid permissions set. Now when program is executed, the program runs as root user. So file /var/notes is also owned by root when created. 

reader@hacking:~/booksrc $ cat /var/notes
cat: /var/notes: Permission denied
reader@hacking:~/booksrc $ sudo cat /var/notes
?
this is a test of multiuser notes
reader@hacking:~/booksrc $ sudo hexdump -C /var/notes
00000000 e7 03 00 00 0a 74 68 69 73 20 69 73 20 61 20 74	|.....this is a t|
00000010 65 73 74 20 6f 66 20 6d 75 6c 74 69 75 73 65 72	|est of multiuser|
00000020 20 6e 6f 74 65 73 0a								| notes.|
00000027
reader@hacking:~/booksrc $ pcalc 0x03e7
999		0x3e7		0y1111100111
reader@hacking:~/booksrc $

First 4 bytes: e7 03 00 00 are 0x000003e7 which equals 999, the real user id. 

In order for normal user to be able to read the note data, a corresponding setuid root program is needed.

notesearch.c -> reads note data and only displays the notes written by that user ID. Additionally, an optional command-line argument can be supplied for a search string. When used, only notes matching the search string will be displayed

reader@hacking:~/booksrc $ gcc -o notesearch notesearch.c
reader@hacking:~/booksrc $ sudo chown root:root ./notesearch
reader@hacking:~/booksrc $ sudo chmod u+s ./notesearch
reader@hacking:~/booksrc $ ./notesearch
[DEBUG] found a 34 byte note for user id 999
this is a test of multiuser notes
-------[ end of note data ]-------
reader@hacking:~/booksrc $

WHen compiled and setuid root, the notesearch program works as expected. 

What if different users use the the notetaker and notesearch programs

reader@hacking:~/booksrc $ sudo su jose
jose@hacking:/home/reader/booksrc $ ./notetaker "This is a note for jose"
[DEBUG] buffer
@ 0x804a008: 'This is a note for jose'
[DEBUG] datafile @ 0x804a070: '/var/notes'
[DEBUG] file descriptor is 3
Note has been saved.
jose@hacking:/home/reader/booksrc $ ./notesearch
[DEBUG] found a 24 byte note for user id 501
This is a note for jose
-------[ end of note data ]-------
jose@hacking:/home/reader/booksrc $

reader@hacking:~/booksrc $ ./notetaker "This is another note for the reader user"
[DEBUG] buffer @ 0x804a008: 'This is another note for the reader user'
[DEBUG] datafile @ 0x804a070: '/var/notes'
[DEBUG] file descriptor is 3
Note has been saved.
reader@hacking:~/booksrc $ ./notesearch
[DEBUG] found a 34 byte note for user id 999
this is a test of multiuser notes
[DEBUG] found a 41 byte note for user id 999
This is another note for the reader user
-------[ end of note data ]-------
reader@hacking:~/booksrc $

Even though these programs auid root and have full read and write access to the /vars/notes datafile, the program logic in the notesearch program prevents the current user from viewing other users' notes. 

struct members take up memory of a struct. First member will have same address as the address of the struct. 
