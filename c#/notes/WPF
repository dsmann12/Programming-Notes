WINDOWS PRESENTATION FORMAT AND XAML

Extensible Application Markup Langauge (XAML) - zammel. 

Pre-WPF. GUI development had to call a wide range of APIs for different functionality. 

Desired Functionality 				Technology
Building windows with controls 		Windows Forms
2D graphics support 				GDI+ (System.Drawing.dll)
3D graphics support 				DirectX APIs
Support for streaming video 		Windows Media Player APIs
Support for flow-style documents 	Programmatic manipulation of PDF files

WPF merged these unrelated programming tasks into a single unified object model. 

Post-WPF

Desired Functionality 				Technology
Building forms with controls 		WPF
2D graphics support 				WPF
3D graphics support 				WPF
Support for streaming video 		WPF
Support for flow-style documents 	WPF

SEPARATION OF CONCERNS VIA XAML


WPF provides a way to cleanly separate the look and feel of a GUI app from programming logic that derives it. Using XAML, it is
possible to define the UI of an application via XML markup. This markup can be connected to a related C# code file to provide 
guts of functionality. 

XAML allows you to define not only simple UI elements (buttons, grids, list boxes, etc) in markup, but also interactive 2D and 
3D graphics, animations, data binding logic, and multimedia functionality (such as video playback). 

WPF controls can be modified through styles and templates, allwing you to change overall look and feel of app with minimal fuss. 

Only reason to build a custom WPF control from ground up is if you need to change behaviors of control (add custom methods, 
properties, or events, subclass an existing control to override virtual members. 

To simply change look and feel of control, can do so through markup. 

GDI - C based API. Low level used to perform all graphical rendering requests. Been part of Windows for years. 

WPF different in that GDI not used when rendering graphical data. All rendering operations (2D graphics, 3D graphics, animations,
control rendering, etc) now make use of DirectX API. 

Benefit is that WPF apps will automatically take advantage of hardware and software optimizations. Also WPF apps can tap into very
rich graphical services (blur effects, anti-aliasing, transparency, etc) without complexity of programmign directly against DirectX
API.

Although WPF does push all rendering requests to DirectX layer, building an app with unmanaged C++ and DirectX directly will perform
faster (god for 3D video games). 

WPF - API for building desktop apps that integrates various desktop APIs into a signle object model and provides a clean separation
of concerns via XAML. 

Core WPF Features:
-A number of layout managers to provide extremely flexible control over placement and reposition of content. 
-Use of an enhanced data-binding enginge to bind content to UI elements in a variety of ways
-A built in style engine which allows you to define "themes" for a WPF app
-Use of vector graphics ,which allows content to be automatically resized to fit the size and resolution of screen hosting the app
-Support for 2D and 3D graphics, animations, and video and audio playback
-A rich typography API such as support for XML Paper Specification (XPS) documents, fixed documents (WYSIWYG), flow documents, and 
document annotations (e.g. Stick Notes API). 
-Support for interoperating with legacy GUI models (Windows Forms, ActiveX, and Wind32 HWNDs). Can incorporate custom Windows Forms 
controls into a WPF app and vice versa. 

DESKTOP APPLICATIONS

This type of WPF app will make use (at a minimum) of the Window and Application class types, in addition to expected set of dialog 
boxes, toolbars, status bars, menu systems, and other UI elements.

Can see examples at https://windowsclient.net

NAVIGATION BASED APPLICATIONS

WPF apps can optionally make us of navigation based structure, which makes a traditional desktop app take basic behavior of web
browser. Provides a forward and back button that allows end user to move back and forth between various UI displays called pages. 

This type of app maintains a list of each page nad provides the necessary infrastructure to navigate between them, pass data across
pages and maintain a history list. 

XBAP Apps

WPF allows you to build apps that can be hosted within a web browser. 

XAML browser application (XBAP). End user navigates to give URL, at which point the XBAP (essentially a collection of Page objects) is
transparently downloaded and installed to local machine. Hosted directly within browser and adopts the browsers intrinsic navigation 
system. 

XBAP alllows you to create sophisticated UIs that are much more epxressive than a typical web page built with HTML and JavaScript. 
Web browser is just a container for WPF Page objects and is not displaying ASP.NET web pages. 

However, given that these Page objects are deployed to a remote web server, XBAPs can be easily versioned and updated without need to
redeploy executables to user's desktop. 

Downside is XBAPs must be hosted within Internet Explorer or Firefox. Not supported on Microsoft Edge. 

Also machine viewing XBAP must have a local installation of .NET framework. So do not work on Linux or Mac. 

The WPF/SILVERLIGHT RELATIONSHIP

Cross-platform, cross-browser WPF-based technology termed Silverlight. A competitor to Adobe Flash, with benefit of using C# and XAML 
rather than new set of tools and languages. It is a subset of WPF functionality which is usde to build highly interactive plugins for 
a larger HTML-based web page. 

Reality, it is unique distribution of .NEt platform which ships with mini CLR and mini version of .NET base class libraries. 

Unlike XBAP, user's machine does not need a full installation of .NET framework. As long as machine has Silverlight runtime installed,
browser will load the Silverlight runtime and display the Silverlight app automatically. Can work on Mac. 

INVESTIGATING THE WPF ASSEMBLIES

WPF is ultimately little more than a collection of types bundled within .NET assemblies

Assembly 							Meaning in Life
PresentationCore.dll 				This assembly defines numerous namespaces that constitute the foundation
									of the WPF GUI layer. For example, this assembly contains support for the WPF
									Ink API (for programming against stylus input for Pocket PCs and Tablet PCs),
									animation primitives, and numerous graphical rendering types.

PresentationFramework.dll 			This assembly contains a majority of the WPF controls, the Application
									and Window classes, support for interactive 2D graphics and numerous types
									used in data binding.

System.Xaml.dll 					This assembly provides namespaces that allow you to program against a
									XAML document at runtime. By and large, this library is only useful if you are
									authoring WPF support tools or need absolute control over XAML at runtime.

WindowsBase.dll 					This assembly defines types that constitute the infrastructure of the
									WPF API, including those representing WPF threading types, security types,
									various type converters, and support for dependency properties and routed events

These 4 assemvlies define a number of new namespaces and hundred of new .NET classes, interfaces, structure, enumerations, and 
delegates.

Namespace 						Meaning in Life
System.Windows 					This is the root namespace of WPF. Here, you will find core classes
								(such as Application and Window) that are required by any WPF
								desktop project.

System.Windows.Controls 		Contains all of the expected WPF widgets, including types to build menu
								systems, tool tips, and numerous layout managers.

System.Windows.Data 			Contains types to work with the WPF data-binding engine, as well as
								support for data-binding templates.

System.Windows.Documents 		Contains types to work with the documents API, which allows you to
								integrate PDF-style functionality into your WPF applications, via the
								XML Paper Specification (XPS) protocol.

System.Windows.Ink 				Provides support for the Ink API, which allows you to capture input from
								a stylus or mouse, respond to input gestures, and so forth. Very useful for
								Tablet PC programming; however, any WPF can make use of this API.

System.Windows.Markup			 This namespace defines a number of types that allow XAML markup
								(and the equivalent binary format, BAML) to be parsed and processed
								programmatically.

System.Windows.Media 			This is the root namespace to several media-centric namespaces. Within
								these namespaces you will find types to work with animations, 3D
								rendering, text rendering, and other multimedia primitives.

System.Windows.Navigation 		This namespace provides types to account for the navigation logic
								employed by XAML browser applications (XBAPs) as well as standard
								desktop applications that require a navigational page model.

System.Windows.Shapes 			Defines classes that allow you to render interactive 2D graphics that
								automatically respond to mouse input.

THE ROLE OF THE APPLICATION CLASS

System.Windows.Application - represents a global instance of a running WPF application. Supplied a Run() method (to start app), a 
series of events that you are able to handle in order to interact with the app's lifetime (such as Startup and Exit), and a number of 
events that are specific to XAML browser apps (such as events that fire as a user navigates between pages)

Property 					Meaning in Life
Current 					This static property allows you to gain access to the running Application object
							from anywhere in your code. This can be very helpful when a window or dialog box
							needs to gain access to the Application object that created it, typically to access
							application-wide variables and functionality.

MainWindow 					This property allows you to programmatically get or set the main window of the
							application.

Properties 					This property allows you to establish and obtain data that is accessible throughout all
							aspects of a WPF application (windows, dialog boxes, etc.).

StartupUri 					This property gets or sets a URI that specifies a window or page to open automatically
							when the application starts.

Windows 					This property returns a WindowCollection type, which provides access to each window
							created from the thread that created the Application object. This can be very helpful
							when you want to iterate over each open window of an application and alter its state
							(such as minimizing all windows).

CONSTRUCTING APPLICATION CLASS

Any WPF app will need to define a class that extends Application. Within this class, you will define program's entry point (Main()), 
which creates an instance of this subclass and typically handles the Startup and Exit events. 

// Define the global application object
// for this WPF program.
class MyApp : Application
{
[STAThread]
static void Main(string[] args)
{
// Create the application object.
MyApp app = new MyApp();
 
// Register the Startup/Exit events.
app.Startup += (s, e) => { /* Start up the app */ };
app.Exit += (s, e) => { /* Exit the app */ };
}
}

Within startup handler, will most often process any incoming command line arguments and launch main window of program. 

Exit handler is where you can author any necessary shutdown logic for program (save user preference, write to Windows registry). 

WINDOWS PROPERTY

Windows - property exposed by Application class which provides access to a collection represneting each window loaded into memory for
current WPF app. As you create new Window objects, they are automatically added into the Application.Windows collection. 

static void MinimizeAllWindows()
{
foreach (Window wnd in Application.Current.Windows)
{
wnd.WindowState = WindowState.Minimized;
}
}

THE ROLE OF THE WINDOW CLASS

System.Windows.Window (located in PresentationFramework.dll) represents a single window owned by the Application derived class, 
including any dialog boxes displayed by main window. 

Window has series of parent classes, each of which bring more functionality to the table. 

ROLE of SYSTEM.WINDOWS.CONTROLS.CONTENCONTROL

System.Windows.Controls.ContentControl - direct parent of Window. Base class provides derived typed with the ability to hose a single 
piece of content, which, refers to the visual data placed within the interior of the control's surface area via the Content property. 
WPF content model makes it very simple to customize basic look and feel of a content control. 

Tend to assume for a button, content is simple string literal. If using XAML to describe a WPF control, and the value you want to 
assign to the Content property can be captured as a simple string, you may set the Content property within the element's opening 
definition as so:

<!-- Setting the Content value in the opening element -->
<Button Height="80" Width="100" Content="OK"/>

What if wanted button to have more than simple string, like a custom graphic and blurb of text. 

In other UI frameworks such as WindowsForms, you would be required to build a custom control. No need to with WPF. 

When you want to assign the Content property to avalue that cannot be captured as a simple array of characters, you can't assign it 
using an attribute in control's opening definition. Rather, you must define the content data implicitly, within the element's scope. 

Example, following <Button> contains a <StackPanel> as content, which itself contains some unique data (an <Ellipse> and <Label>, to
be exact).

<!-- Implicitly setting the Content property with complex data -->
<Button Height="80" Width="100">
	<StackPanel>
		<Ellipse Fill="Red" Width="25" Height="25"/>
		<Label Content ="OK!"/>
	</StackPanel>
</Button>

XAML's property-element syntax - can be used to set complex content. 

Following functionally equivalent <Button> definition, which sets the Content property explicitly using property-element syntax:

<!-- Setting the Content property using property-element syntax -->
<Button Height="80" Width="100">
<Button.Content>
<StackPanel>
<Ellipse Fill="Red" Width="25" Height="25"/>
<Label Content ="OK!"/>
</StackPanel>
</Button.Content>
</Button>

Not every WPF element derives from ContentControl and therefore not all controls support this unique content model. 

THE ROLE OF SYSTEM.WINDOWS.CONTROLS.CONTROL

Unlike ContentControl, all WPF controls share the Control base class as common parent. 

This base class provides numerous core members that account for basic UI functionality. Control defines properties to establish control's
size, opacity, tab, order logic, the display cursor, background color, and so forth. Also provides support for templating services. 

Members 											Meaning in Life
Background, Foreground, BorderBrush,
BorderThickness, Padding,
HorizontalContentAlignment,
VerticalContentAlignment 							These properties allow you to set basic settings regarding
													how the control will be rendered and positioned.

FontFamily, FontSize, FontStretch, FontWeight 		These properties control various font-centric settings.

IsTabStop, TabIndex 								These properties are used to establish tab order among
													controls on a window.

MouseDoubleClick, PreviewMouseDoubleClick 			These events handle the act of double-clicking a widget.
													Template This property allows you to get and set the control’s
													template, which can be used to change the rendering
													output of the widget.

ROLE OF SYSTEM.WINDOWS.FRAMEWORKELEMENT

System.Windows.FrameworkElement - Of all types within a Window's inheritance chain, the UIElement base class provides the greatest 
amount of functionality. Key task of UIElement is to provide the derived type with numerous events to allow derived type to receive 
focus and process input requests. 

Example, class provides numerous events to account for drag-and-drop, mouse movement, keyboard input, and stylus input

Members 								Meaning in Life
Focusable, IsFocused 					These properties allow you to set focus on a given derived type.
										IsEnabled This property allows you to control whether a given derived type is
										enabled or disabled.

IsMouseDirectlyOver, IsMouseOver 		These properties provide a simple way to perform hit-testing logic.

IsVisible, Visibility 					These properties allow you to work with the visibility setting of a
										derived type.

RenderTransform 						This property allows you to establish a transformation that will be
										used to render the derived type.

THE ROLE OF SYSTEM.WINDOWS.MEDIA.VISUAL

System.Windows.Media.Visual - class type provides core rendering support in WPF, which includes hit testing of graphical data, 
coordinate transformation, and bounding box calculations. Visual class interacts with the underlying DirectX subsystem to actually
draw data on the screen. Provides most lightweight way to render graphical data, but it also entails greatest amount of manual code
to account for all required services. 

ROLE OF SYSTEM.WINDOWS.DEPENDENCYOBJECT

Dependency properties - particular flavor of .NET properties. This style or property provides extra code to allow the property to 
respond to several WPF technologies such as styles, data binding, animations, and so forth. In order to support this new property 
scheme, it will need to derive from DependencyObject base class. 

THE ROLE OF SYSTEM.WINDOWS.THREADING.DISPATCHEROBJECT

System.Windows.Threading.DispatcherObject - this type provides one property of interest, Dispatcher, which returns associated 
System.Windows.Threading.Dispatcher object. Dispatcher class is entry point to the event queue of the WPF application, and it provides
basic constructs for dealing with concurrency and threading. 

BUILDING WPF APP WITHOUT XAML

Although mos tWPF apps will make use of XAML, it is optional. Anything that can be expressed in XAML can be expressed in code and 
vice-versa. 

To illustrate, let’s create a minimal but complete application without the use of XAML using
the Application and Window classes directly. Begin by creating a new Console Application named
WpfAppAllCode (don’t worry; you will use the Visual Studio WPF project template later in this chapter). Go
into the project properties and change the output type to Windows Application (this prevents the console
window from popping up). Next, access the Project Add Reference dialog box and add a reference to
WindowsBase.dll, PresentationCore.dll, System.Xaml.dll, and PresentationFramework.dll.

// A simple WPF application, written without XAML.
using System;
using System.Windows;
using System.Windows.Controls;

namespace WpfAppAllCode
{
// In this first example, you are defining a single class type to
// represent the application itself and the main window.
class Program : Application
{
[STAThread]
static void Main(string[] args)
{
// Handle the Startup and Exit events, and then run the application.
Program app = new Program();
app.Startup += AppStartUp;
app.Exit += AppExit;
app.Run(); // Fires the Startup event.
}
 
static void AppExit(object sender, ExitEventArgs e)
{
MessageBox.Show("App has exited");
}
 
static void AppStartUp(object sender, StartupEventArgs e)
{
// Create a Window object and set some basic properties.
Window mainWindow = new Window();
mainWindow.Title = "My First WPF App!";
mainWindow.Height = 200;
mainWindow.Width = 300;
mainWindow.WindowStartupLocation = WindowStartupLocation.CenterScreen;
mainWindow.Show();
}
}
}

Program class extends the System.Windows.Application class. Within Main method, you create instance of application object and handle
the Startup and Exit events using method group conversion syntax. Also can specify underlying delegates by name. 

In following modified Main() method, notice that Startup event works in conjunction with StartupEventHandler delegate which can only 
ponit to methods taking an Object as the first parameter and a StartupEventArgs as the second. The Exit event on other hand works with
the ExitEventHandler delegate which demands that method pointed to take an ExitEventArts type as second parameter. 

[STAThread]
static void Main(string[] args)
{
// This time, specify the underlying delegates.
Program app = new Program();
app.Startup += new StartupEventHandler(AppStartUp);
app.Exit += new ExitEventHandler(AppExit);
app.Run(); // Fires the Startup event.
}

AppStartUp() - configured to create a new Window object, establish some very basic property settings, and call Show() to display the 
window on the screen in modeless fashion. ShowDialog() can be used to launch a modal dialog. AppExit() simply makes use of WPF 
MessageBox class to display a diagnostic message when application is being terminated. 

CREATING A STRONGLY TYPED WINDOW

Application-derived class directly creates an instance of Window type upon application startup. 

Ideally, would create a class deriving from Window in order to encapsulate its appearance and functionality. Add another class to your
project named MainWindow, and add the following class definition. 

class MainWindow : Window
{
public MainWindow(string windowTitle, int height, int width)
{
this.Title = windowTitle;
this.WindowStartupLocation = WindowStartupLocation.CenterScreen;
this.Height = height;
this.Width = width;
}
}

Can then update Startup event handler as so:

static void AppStartUp(object sender, StartupEventArgs e)
{
// Create a MainWindow object.
var main = new MainWindow("My better WPF App!", 200, 300);
main.Show();
}

CREATING A SIMPLE USER INTERFACE

Adding a UI element to a Window in C# will involve basic steps:

1. Define a member variable to represent the control
2. Configure the control's look and feel upon Window construction
3. Assign the control to the inherited Content property, or alternatively, as a parameter to the inherited AddChild() method

Recall, WPF control content model demands that Content property is set to a single element. Usually that single piece of content is a 
layout manager, such as DockPanel, Grid, Canvas, or StackPanel. Within layout manager you can have any combination of internal controls,
including other nested layout managers. 

class MainWindow : Window
{
// Our UI element.
private Button btnExitApp = new Button();
 
public MainWindow(string windowTitle, int height, int width)
{
// Configure button and set the child control.
btnExitApp.Click += new RoutedEventHandler(btnExitApp_Clicked);
btnExitApp.Content = "Exit Application";
btnExitApp.Height = 25;
btnExitApp.Width = 100;
 
// Set the content of this window to a single button.
this.Content = btnExitApp;
 
// Configure the window.
this.Title = windowTitle;
this.WindowStartupLocation = WindowStartupLocation.CenterScreen;
this.Height = height;
this.Width = width;
this.Show();
}

Notice: Click event of WPF Button works in conjunction with a delegate named RoutedEventHandler. Targets of RoutedEventHandler delegate
must supply an object as the first parameter and a RoutedEventsArgs as the second. 

INTERACTING WITH APPLICATION-LEVEL DATA

Recall Application class defines a property named Properties, which allows you to define a collection of name/value pairs via a type 
indexer. Indexer has been defined to operate on type System.Object. Using this approach, it is simple to share data across all windows 
in a WPF application. 

Example: Update current Startup event handler to check incoming command line arguments for a value named /GODMODE (common cheat code for
many PC video games). If you find this tokem, you will establish a bool value set to true within the properties collection of the same
name. (otherwise you will set value to false). 

private static void AppStartUp(object sender, StartupEventArgs e)
{
// Check the incoming command-line arguments and see if they
// specified a flag for /GODMODE.
Application.Current.Properties["GodMode"] = false;
foreach(string arg in e.Args)
{
if (arg.ToLower() == "/godmode")
{
Application.Current.Properties["GodMode"] = true;
break;
}
}
// Create a MainWindow object.
MainWindow wnd = new MainWindow("My better WPF App!", 200, 300);
}

private void btnExitApp_Clicked(object sender, RoutedEventArgs e)
{
// Did user enable /godmode?
if((bool)Application.Current.Properties["GodMode"])
{
MessageBox.Show("Cheater!");
}
this.Close();
}

HANDLING CLOSING OF A WINDOW OBJECT

End users can shut down a window using nermous built-in system-level techniques (clicking the "X" close button on the window's frame)
or by indirectly calling the Close() method in response to some user interaction element. In either case, WPF provides two events that 
you can intercept to determine whether use it truly ready to shut down window and remove it from memory. 

First event is Closing which works in conjunction with the CancelEventHandler delegate. This delegate expects target methods to take 
System.ComponentModel.CancelEventArgs as second parameter. CancelEventArgs provides the Cancel property, which when set to true will 
prevent the window from actually closing. If user ddoes wish to close window, CancelEventArgs.Cancel can be set to false. Will cause 
Closed event to fire (which works with System.EventHandler delegate), making it th epoint at which the window is about to be closed. 

INTERCEPTING MOUSE EVENTS

WPF API provides a number of events you can capture in order to interact with the mouse. 

Base class UIElement defines a number of mouse centric events such as MouseMove, MouseUp, MouseDown, 
MouseEnter, MouseLeave, and so forth. 

Ex: MouseMove event. 

This event works in conjunction with the System.Windows.Input.MouseEventHandler delegate, which expects to 
target a System.Windows.Input.MouseEventArgs type as second parameter. 

Using MouseEventArgs you are able to extract out the (x, y) position of the mouse and other relevant details:

public class MouseEventArgs : InputEventArgs
{
...
public Point GetPosition(IInputElement relativeTo);
public MouseButtonState LeftButton { get; }
public MouseButtonState MiddleButton { get; }
public MouseDevice MouseDevice { get; }
public MouseButtonState RightButton { get; }
public StylusDevice StylusDevice { get; }
public MouseButtonState XButton1 { get; }
public MouseButtonState XButton2 { get; }
}

XButton1 and XButton2 properties allow you to interact with "extended mouse buttons" such as "next" and "previous" buttons. Often used
with browser's history list to navigate between visited pages. 

GetPosition() allows you get the (x, y) value relative to a UI element on the window. If want position relative to activated window, pass
in this. Handle MouseMove event in cosntructor like so:

public MainWindow(string windowTitle, int height, int width)
{
...
this.MouseMove += MainWindow_MouseMove;
}

private void MainWindow_MouseMove(object sender,
System.Windows.Input.MouseEventArgs e)
{
// Set the title of the window to the current (x,y) of the mouse.
this.Title = e.GetPosition(this).ToString();
}

INTERCEPTING KEYBOARD EVENTS

UIElement defines number of events you can capture to intercept keypresses from the keyboard on the active element (e.g. KeyUo, KeyDown). 
The KeyUp and KeyDown events both work with the System.Windows.Input.KeyEventHandler delegate, which expects the target's second event 
handler to be of type KeyEventArgs, which defines several public properties of interest:

public class KeyEventArgs : KeyboardEventArgs
{
...
public bool IsDown { get; }
public bool IsRepeat { get; }
public bool IsToggled { get; }
public bool IsUp { get; }
public Key Key { get; }
public KeyStates KeyStates { get; }
public Key SystemKey { get; }
}

private void MainWindow_KeyDown(object sender, System.Windows.Input.KeyEventArgs e)
{
// Display key press on the button.
btnExitApp.Content = e.Key.ToString();
}

BUILDING WPF APPLICATION USING ONLY XAML

Typical WPF application will pair C# code files with related XAML source file. Together they represent entirety of a given Window or 
Application, as well as other class types you have not yet examined, such as UserControl and Page.

Code File Approach - XAML + C# code for building WPF application. 

XAML files will contain markup that describes the look and feel of the window, while the related C# code files contain the implementation
logic. Overall XAML file may describe the overall layout system, the controls within that layout system, and specify the names of various
event handlers. 

XAML - an XML based grammar that allows you to define the state (and functionality to an extent) of a tree of .NET objects through markup. 
Can be used to describe any tree of nonabstract .NET types (including own custom types in a custom .NET assembly), provided each supports 
a default constructor. Markup within a *.xaml file is transformed into a full blown object model. 

XAML files very self-describing. By and large, each element represents a type name (Button, Window, Application) within a given .NET 
namespace. Attributes within the scope of an opening element map to properties (Height, Width, etc). and events (Startup, Click, etc). 

<!-- Defining a WPF Button in XAML -->
<Button Name = "btnClickMe" Height = "40" Width = "100" Content = "Click Me" />

Is the same as:

// Defining the same WPF Button in C# code.
Button btnClickMe = new Button();
btnClickMe.Height = 40;
btnClickMe.Width = 100;
btnClickMe.Content = "Click Me";

Downside, XAML is verbose and case sensitive. 

Majority of task relegated to Visual Studio, Microsoft Expresssion Blend, or other tools. Can go in and fine tune if necessary. 

DEFINING A WINDOW OBJECT IN XAML

In C#, MainWindow is Window-derived class was defined as class type that extends System.Windows.Window base. It contains a single Button 
object that calls a registered event handler when clicked.

<!-- Here is your Window definition -->
<Window x:Class="WpfAppAllXaml.MainWindow"
	xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
	xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
	Title="A Window built using 100% XAML"
	Height="200" Width="300"
	WindowStartupLocation ="CenterScreen">
	<Windows.Content>
		<!-- This window has a single button as content -->
		<Button x:Name="btnExitApp" Width="133" Height="24"
		Content = "Close Window" Click ="btnExitApp_Clicked"/>
	</Window.Content>
 
	<!-- The implementation of your button's Click event handler! -->
	<x:Code>
		<![CDATA[
			private void btnExitApp_Clicked(object sender, RoutedEventArgs e)
			{
				this.Close();
			}			
		]]>
	</x:Code>
</Window>

Root eleent <Window> makes us of Class attribute, which is used to specify name of the C# class that will be genereated when XAML is 
processed. The Class attribute is prefixed with the x: tag prefix. 

"http://schemas.microsoft.com/winfx/2006/xaml" - refers the XML namespace. If you want to reference item is this XAML namespace, must 
prefix the x: token. 

Within <Window> are specified values for Title, Height, Width, and WindowStartupLocation attributes, which are direct mapping to properties 
of the same name supported by the System.Windows.Window class in the PresentationFramework.dll assembly. 

Within scope of Window's definition is markup to describe look and feel of a Button object that is used to implicitly set the Content 
property of the window. Sets up variable name with x:Name token and overall dimensions. Also handles Click event of Button type by assigning
the method to delegate to when the Click event occurs. 

The <x:Code> element allows you to author event handlers and other methods of class within a *.xaml file. 

DEFINING APPLICATION OBJECT IN XAML

<!-- The Main() method seems to be missing!
However, the StartupUri attribute is the
functional equivalent -->
<Application x:Class="WpfAppAllXaml.MyApp"
xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
StartupUri="MainWindow.xaml">
</Application>

Vlaue assigned to StartupUri represents which XAML resource to load when application starts up. Assigns name of XAML resource defining your
initial Window object, MainWindow.xaml. 

The Main() method is craeted automatically at compile time. But free to use <x:Code> to capture other C# code blocks. 

<Application x:Class="WpfAppAllXaml.MyApp"
	xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
	xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
	StartupUri="MainWindow.xaml" Exit ="AppExit">
	<x:Code>
		<![CDATA[
			private void AppExit(object sender, ExitEventArgs e)
			{
				MessageBox.Show("App has exited");
			}
		]]>
	</x:Code>
</Application>

PROCESSING XAML FILES USING msbuild.exe

Can not directly use C# compiler to create .NET assembly from XAML. The msbuild.exe CL utility does understand how to transform XAML
into C# code and compile this code on fly when it is informed of correc *.targets files. 

msbuild.exe compiled .NET code based on instructions containe dwithin an XML=based build script. Build script files contain the exact same sort of data that is found in the *.csproj file generated by Visual Studio. So can use msbuild.exe or Visual Studio. 

<Project DefaultTargets="Build"
	xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
	<PropertyGroup>
		<RootNamespace>WpfAppAllXaml</RootNamespace>
		<AssemblyName>WpfAppAllXaml</AssemblyName>
		<OutputType>winexe</OutputType>
	</PropertyGroup>
	<ItemGroup>
		<Reference Include="System" />
		<Reference Include="System.XAML" />
		<Reference Include="WindowsBase" />
		<Reference Include="PresentationCore" />
		<Reference Include="PresentationFramework" />
	</ItemGroup>
	<ItemGroup>
		<ApplicationDefinition Include="MyApp.xaml" />
		<Page Include="MainWindow.xaml" />
	</ItemGroup>
	<Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
</Project>

NOTE: This file cannot be built using VS because it contains minimal code to build. 

<PropertyGroup> element used to specify some basic aspects of build, such as root namespace, name of resulting assembly, and output type. 

First <ItemGroup> specifies set of external assemblies to reference with current build. 

Second <ItemGroup>. <ApplicatoinDefinition>'s Include attribute is assigned to .xaml file that defines application object. The <Page>'s 
Inlcude attribute can be used to list each of remaining *.xaml files that define the windwos (and pages) processed by application object.


<import> References Microsoft.CSharp.Targets, which contains data to interact with C# compiler. 

msbuild WpfAppAllXaml.csproj

TRANSFORMING MARKUP INTO A .NET ASSEMBLY

The *.targets files specified in an msbuild script contain numerous instructions to translate XAML elements into C# code. When msbuild.exe 
processed the .csproj file, it produced two files with form of *.g.cs (g denoted autogenerated) that were saved to /obj/Debug. Baed on named
of *.xaml files, the C# files in question are MainWindow.g.cs and MyApp.g.cs

Opening MainWindow.g.cs will show a MainWindow class which extends Window base class. Name of class is direct result of the x:Class attribute
value within the opening <Button> declaration. Also contains handler for button's Click event. 

public partial class MainWindow :
System.Windows.Window, System.Windows.Markup.IComponentConnector
{
internal System.Windows.Controls.Button btnExitApp;
 
private void btnExitApp_Clicked(object sender, RoutedEventArgs e)
{
this.Close();
}
...
}

Class provides a private member variable of type bool named _contentLoaded. Is used to determine and ensure the content of window is assigned
only once. 

public partial class MainWindow :
System.Windows.Window, System.Windows.Markup.IComponentConnector
{
// This member variable will be explained soon enough.
private bool _contentLoaded;
...
}

Notice: compiler generated class explicitly implements the WPF IComponentConnector interface defined in System.Windows.Markup namespace. 
This interface defines a single method called Connect(), which has been implemented to prep each control define in markup and rig up the event
logic as specified within original MainWindow.xaml file. Before method completes, the _contentLoaded member variable is set to true. 

void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target)
{
switch (connectionId)
{
case 1:
this.btnExitApp = ((System.Windows.Controls.Button)(target));
this.btnExitApp.Click += new
System.Windows.RoutedEventHandler(this.btnExitApp_Clicked);
return;
}
this._contentLoaded = true;
}

The MainWindow class also defines and implements a method named InitializeComponent(). The method resolves the location of an embedded 
assembly resource that is named identical to the original *.xaml file. 

public void InitializeComponent()
{
if (_contentLoaded)
{
return;
}
_contentLoaded = true;
System.Uri resourceLocater = new
System.Uri("/WpfAppAllXaml;component/mainwindow.xaml",
System.UriKind.Relative);
System.Windows.Application.LoadComponent(this, resourceLocater);
}

What is this embedded resource?

ROLE OF BAML

msbuild.exe processees .csproj files and generates a .baml file. Full name based on initial MainWindow.xaml file. So MainWindow.baml

Binary Application Markup Language (BAML) - compact binary representation of original XAML data. Embedded as a resource (via generated
*.g.resource file) into compiled assembly. 

File contains all data needed to establish look and feel of UI widgets. 

Importatn to understand that WPF app contains within itself a binary representation of the markup (BAML). At runtime. BAML will be plucked
out of resource container and used to make sure all windows and controls are initialized to correct look and feel. 

So never need to ship original markup .xaml files. 

mAPPING APPLICATION XAML MARKUP TO C#

MyApp.g.cs

Implementation of this method calls InitializeComponent() on Application-derived type, which, in turn, sets the StartupUri property, 
allowing each of the objects to establish its correct property settings based on binary XAML definition.

namespace WpfAppAllXaml
{
public partial class MyApp : System.Windows.Application
{
void AppExit(object sender, ExitEventArgs e)
{
MessageBox.Show("App has exited");
}
[System.Diagnostics.DebuggerNonUserCodeAttribute()]
public void InitializeComponent()
{
this.Exit += new System.Windows.ExitEventHandler(this.AppExit);
this.StartupUri = new System.Uri("MainWindow.xaml", System.UriKind.Relative);
}
 
[System.STAThreadAttribute()]
[System.Diagnostics.DebuggerNonUserCodeAttribute()]
public static void Main() {
WpfAppAllXaml.MyApp app = new WpfAppAllXaml.MyApp();
app.InitializeComponent();
app.Run();
}
}
}

XAML-to-ASSEMBLY PROCESS SUMMARY

MainWindow.xaml
MyApp.xmal
*.csproj

	||
	VV
msbuild.exe
and Required C#
and WPF Targets
	||
	vv
Output to \Obj\Debug directory
MainWindow.g.cs
MyApp.g.cs
MainWindow.baml
WpfAppAllXaml.g.resources
	||
	vv
C# Compiler
-Compile C# files
-Embed *.g.resources as Resource
	||
	vv
WpfAppAllXaml.exe
[Embedded BAML Resource]

UNDERSTANDING SYNTAX OF WPF XAML

Kaxaml - XAML editor/parser. Much more straightforward way to test XAML snippets than using Visual Studio.

When first open it, will see markup for a <Page> control:

<Page
xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
<Grid>
 
</Grid>
</Page>

Like Window, Page contains various layout managers and control. Unlike a Window, Page objects cannot run as standalone entities. 
They must be placed in suitable host such as a NavigationWindow, Frame, or web browser. 

<Page
xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
<Grid>
<!-- A button with custom content -->
<Button Height="100" Width="100">
<Ellipse Fill="Green" Height="50" Width="50"/>
</Button>
</Grid>
</Page>

Kaxaml does not allow you to author any markup that entails code compilation. 

XAML XML NAMESPACES AND XAML KEYWORDS

Root element of WPF XAML documents (<Window>, <Page>, <UserControl>, or <Application>) will almost always make reference to following
two predefined XML namespaces.

<Page
xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
<Grid>
 
</Grid>
</Page>

1. http://schemas.microsoft.com/winfx/2006/xaml/presentation - maps a slew of WPF .NET namespaces for use by current *.xaml file
(System.Windows, System.Windows.Controls, System.Windows.Data, System.Windows.Ink, System.Windows.Media, System.Windows.Navigation)

This one to many mapping is hard coded within WPF assemblies (WindowsBase.dll, PresentationCore.dll, PresentationFramework.dll) 
using the assembly-level [XmlnsDefinition] attribute. 

If you open Visual Studio object browser and select PresentationCore.dll asembly, you will see listings such as following which 
essentially imports System.Windows:

[assembly: XmlnsDefinition("http://schemas.microsoft.com/winfx/2006/xaml/presentation",
"System.Windows")]

2.http://schemas.microsoft.com/winfx/2006/xaml - used to include XAML specific keywords as well as inclusion of System.Windows.Markup 
namespace:

[assembly: XmlnsDefinition("http://schemas.microsoft.com/winfx/2006/xaml",
"System.Windows.Markup")]

One rule of any well-formed XML document is that opening root element designates one XML namespace as primary namespace, which typically
is the namespace that contains the most commonly used items. If root element requires inclusion of additional secondary namespaces (as 
seen here), they must be defined using a unique tag prefix (to resolve any name clashes). As convention, prefix is simply x; however,
this can be any unique token you require, such as XamlSpecificStuff:

<Page
xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
xmlns:XamlSpecificStuff="http://schemas.microsoft.com/winfx/2006/xaml">
<Grid>
<!-- A button with custom content -->
<Button XamlSpecificStuff:Name="button1" Height="100" Width="100">
<Ellipse Fill="Green" Height="50" Width="50"/>
</Button>
</Grid>
</Page>

Problem with using a wordy XML namespace prefix (like XamlSpecificStuff) is you must type them each time XAML file needs to refer to one 
of items defined within this XAML centric XML namespace. 

Beyond x:Name, x:Class and x:Code keywords, the http://schemas.microsoft.com/winfx/2006/xaml xml namespace also provides others:

XAML Keyword 				Meaning in Life
x:Array 					Represents a .NET array type in XAML.

x:ClassModifier 			Allows you to define the visibility of the C# class (internal or public) denoted by
							the Class keyword.

x:FieldModifier 			Allows you to define the visibility of a type member (internal, public, private,
							or protected) for any named subelement of the root (e.g., a <Button> within a
							<Window> element). A named element is defined using the Name XAML keyword.

x:Key 						Allows you to establish a key value for a XAML item that will be placed into a
							dictionary element.

x:Name 						Allows you to specify the generated C# name of a given XAML element.

x:Null 						Represents a null reference.

x:Static 					Allows you to make reference to a static member of a type.

x:Type 						The XAML equivalent of the C# typeof operator (it will yield a System.Type
							based on the supplied name).

x:TypeArguments 			Allows you to establish an element as a generic type with a specific type
							parameter (e.g., List<int> vs. List<bool>).

In addition to these two necessary XML namepsace declarations, it is possible and sometimes necessary to define additional tag prefixes in
the opening element of a XAML document. Typically neeeded when need to describe in XAML a .NET class defined in an external assembly.

Example: Say you have built a few custom WPF controls and packaged them in a library named MyControls.dll. Now if you want to create a new
Window that usese these controls, you can establish a custom XML namespace that maps to your library using the clr-namespace and assembly
tokens. 

Example creates a tax prefix name myCtrls which can be used to access controls in the library

<Window x:Class="WpfApplication1.MainWindow"
	xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
	xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
	xmlns:myCtrls="clr-namespace:MyControls;assembly=MyControls"
	Title="MainWindow" Height="350" Width="525">
	<Grid>
		<myCtrls:MyCustomControl />
	</Grid>
</Window>

The clr namespace is assigned the name of the .NET namespace in the assembly. Whiel assembly token is set to friendlyt name of external
*.dll assembly. 

Can use this syntax for any external .NET library you would like to manipulate in markup. 

Other examples of keywords:

<!-- This class will now be declared internal in the *.g.cs file -->
<Window x:Class="MyWPFApp.MainWindow" x:ClassModifier ="internal"
xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
 
<!-- This button will be public in the *.g.cs file -->
<Button x:Name ="myButton" x:FieldModifier ="public" Content = "OK"/>
</Window>

internal partial class MainWindow : System.Windows.Window,
System.Windows.Markup.IComponentConnector
{
public System.Windows.Controls.Button myButton;
...
}

XAML ELEMENTS, ATTRIBUTES, AND TYPE CONVERTERS

After you establish root element and required XML namespaces, next task it to populate root with a child element. 

In real world WPF app, child would be a layout manager (such as Grid or StackPanel) that contains any number of additional UI elements
that describe the user interface. For now assume just a single button. 

XAML elements map to a class or structure type within a given .NET namespace. Attributes within opening element tag map to properties
or event of the type.

<Page
	xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
	xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
	<Grid>
		<!-- Configure the look and feel of a Button -->
		<Button Height="50" Width="100" Content="OK!"
			FontSize="20" Background="Green" Foreground="Yellow"/>
	</Grid>
</Page>

In Code:

public void MakeAButton()
{
Button myBtn = new Button();
myBtn.Height = 50;
myBtn.Width = 100;
myBtn.FontSize = 20;
myBtn.Content = "OK!";
myBtn.Background = new SolidColorBrush(Colors.Green);
myBtn.Foreground = new SolidColorBrush(Colors.Yellow);
}

WPF ships with number of type converter classes which will be used to transform simple text values into correct underlying type. 

Sometimes need comlex value to XAML attribute. 

Example, you want to build a custom brush to set Background property of Button. 

In Code:

public void MakeAButton()
{
...
// A fancy brush for the background.
LinearGradientBrush fancyBruch =
new LinearGradientBrush(Colors.DarkGreen, Colors.LightGreen, 45);
myBtn.Background = fancyBruch;
myBtn.Foreground = new SolidColorBrush(Colors.Yellow);
}

Howver, can you represent complex brush as a string? No!. XAML provides special syntax that can be used whenever need to assign a 
property value to a complex object termed property-element syntax.

UNDERSTANDING XAML PROPERTY-ELEMENT SYNTAX

Property-element syntax - allows you to assign complex object to a property. 

Here is XAML description for Button that maeks use of LinearGradientBrush to set its Background property:

<Button Height="50" Width="100" Content="OK!"
		FontSize="20" Foreground="Yellow">
	<Button.Background>
		<LinearGradientBrush>
			<GradientStop Color="DarkGreen" Offset="0"/>
			<GradientStop Color="LightGreen" Offset="1"/>
		</LinearGradientBrush>
	</Button.Background>
</Button>

Notice: Within scope of <Button></Button> you have defined a subscope named <Button.Background>. Within this scope, you have defined
a custom <LinearGradientBrush>. 

Generally speaking, any property can be set using Property-Element syntax:

<DefiningClass>
	<DefiningClass.PropertyOnDefiningClass>
		<!-- Value for Property here! -->
	</DefiningClass.PropertyOnDefiningClass>
</DefiningClass>

<Button Height="50" Content="OK!"
		FontSize="20" Foreground="Yellow">
...
	<Button.Width>
		100
	</Button.Width>
</Button>

UNDERSTANDING XAML ATTACHED PROPERTIES

Attached property - XAML special syntax used to set a value to attached property. Allows a child element to set value for a property that
is actually defined in a parent element. 

<ParentElement>
	<ChildElement ParentElement.PropertyOnParent = "Value">
</ParentElement>

Most common use of attached property is to position UI elements within one of the WPF layout manager classes (Grid, DockPanel, etc). 

<Page
	xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
	mlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
	<Canvas Height="200" Width="200" Background="LightBlue">
		<Ellipse Canvas.Top="40" Canvas.Left="40" Height="20" Width="20" Fill="DarkBlue"/>
	</Canvas>
</Page>

Notice: Ellipse defined inside Canvas layout manager is able to inform paraent where to positions it. 

Attached properties not an all-purpose syntax that can be applied to any property of any parent. 

<!-- Error! Set Background property on Canvas via attached property? -->
<Canvas Height="200" Width="200">
	<Ellipse Canvas.Background="LightBlue"
			Canvas.Top="40" Canvas.Left="90"
			Height="20" Width="20" Fill="DarkBlue"/>
</Canvas>

Attached properties area specialized form of a WPF-specific concept termed a dependency property. Unless a property was implemented in 
a very specific manner, you cann set its value using attache property syntax. 

UNDERSTANDING XAML MARKUP EXTENSIONS

Propert values most often represented using a simple string or via property-element syntax. 

Markup extensions - another way to specify value of a XAML attribute. Allow a XAML parser to obtain the value for a property from a 
dedicated, external class. Provide a way to cleanly extend grammar of XAML with new functionality. Represented internally as a class
that derives from MarkupExtension. (x:Array, x:Null, x:Static, and x:Type) are markup extensions in disguise. 

<Element PropertyToSet = "{MarkUpExtension}"/>

<Page
	xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
	xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
	xmlns:CorLib="clr-namespace:System;assembly=mscorlib">
 
	<StackPanel>
		<!-- The Static markup extension lets us obtain a value
				from a static member of a class -->
		<Label Content ="{x:Static CorLib:Environment.OSVersion}"/>
		<Label Content ="{x:Static CorLib:Environment.ProcessorCount}"/>
		<!-- The Type markup extension is a XAML verion of
			the C# typeof operator -->
		<Label Content ="{x:Type Button}" />
		<Label Content ="{x:Type CorLib:Boolean}" />
 
		<!-- Fill a ListBox with an array of strings! -->
		<ListBox Width="200" Height="50">
			<ListBox.ItemsSource>
				<x:Array Type="CorLib:String">
					<CorLib:String>Sun Kil Moon</CorLib:String>
					<CorLib:String>Red House Painters</CorLib:String>
					<CorLib:String>Besnard Lakes</CorLib:String>
				</x:Array>
			</ListBox.ItemsSource>
		</ListBox>
	</StackPanel>
</Page>

First, notice the <Page> definition has new XML namespace declaration which allows you to gain access to System nmespace of mscorlib.dll.
With this XML namespace estblished, you first make use of x:Static markup extension and grab values from OSVersion and ProcessorCount of
System. 

x:Type markup extension allows you to gain access to metadata description of specified item. Simply assigning fully qualified name of 
WPF Button and System.Boolean types

ListBox. Here you are setting ItemsSource proprety to an array of string delclared entirely in markup. 

BUILDING WPF APPLICATIONS USING CODE-BEHIND FILES

code file - approach. XAML files of project contain nothing but markup that describes general state of classes. Code file contains 
implementation details. 

Apply to XAML only file built with msbuild.exe:

Create new C# code file named MainWindow.xaml.cs

// MainWindow.xaml.cs
using System;
using System.Windows;
using System.Windows.Controls;
namespace WpfAppAllXaml
{
public partial class MainWindow : Window
{
public MainWindow()
{
// Remember! This method is defined
// within the generated MainWindow.g.cs file.
InitializeComponent();
}
 
private void btnExitApp_Clicked(object sender, RoutedEventArgs e)
{
this.Close();
}
}
}

Here, you have defined a partial class to contain the event-handling logic that will be merged with the
partial class definition of the same type in the *.g.cs file. Given that InitializeComponent() is defined
within the MainWindow.g.cs file, your window’s constructor makes a call in order to load and process the
embedded BAML resource.

Update xaml to get rid of C# code

<Window x:Class="WpfAppAllXaml.MainWindow"
xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
Title="A Window built using Code Files!"
Height="200" Width="300"
WindowStartupLocation ="CenterScreen">
 
<Window.Content>
<!-- The event handler is now in your code file -->
<Button x:Name="btnExitApp" Width="133" Height="24"
Content = "Close Window" Click ="btnExitApp_Clicked"/>
</Window.Content>
 
</Window>

// MyApp.xaml.cs
using System;
using System.Windows;
using System.Windows.Controls;
namespace WpfAppAllXaml
{
public partial class MyApp : Application
{
private void AppExit(object sender, ExitEventArgs e)
{
MessageBox.Show("App has exited");
}
}
}
The MyApp.xaml file now looks like so:
<Application x:Class="WpfAppAllXaml.MyApp"
xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
StartupUri="MainWindow.xaml"
Exit ="AppExit">
</Application>

Then need to update *.csproj to account for new C# files via the <Compile> elements:

<Project DefaultTargets="Build" xmlns=
		"http://schemas.microsoft.com/developer/msbuild/2003">
	<PropertyGroup>
		<RootNamespace>WpfAppAllXaml</RootNamespace>
		<AssemblyName>WpfAppAllXaml</AssemblyName>
		<OutputType>winexe</OutputType>
	</PropertyGroup>
	<ItemGroup>
		<Reference Include="System" />
		<Reference Include="WindowsBase" />
		<Reference Include="PresentationCore" />
		<Reference Include="PresentationFramework" />
		<Reference Include=”System.Xaml” />
	</ItemGroup>
	<ItemGroup>
		<ApplicationDefinition Include="MyApp.xaml" />
		<Compile Include = "MainWindow.xaml.cs" />
		<Compile Include = "MyApp.xaml.cs" />
		<Page Include="MainWindow.xaml" />
	</ItemGroup>
	<Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
</Project>

msbuild WpfAppAllXaml.csproj

WPF apps created in Visual Studio always make use of this model

BUILDING WPF APPLICATIONS USING VISUAL STUDIO

Choose a WPF application

HANDLING EVENTS USING THE PROPERTIES WINDOW

Double clicking will make custom event handler named:

NameOfControl_NameOfEvent

So button_Click. 

HANDLING EVENTS IN XAML EDITOR

Place mouse within <Window> element and type MouseMeve event followed by equals sign.

Title="MainWindow" Height="350" Width="525" MouseMove="">

private void MainWindow_MouseMove (object sender, MouseEventArgs e)
{
this.Title = e.GetPosition(this).ToString();
}

THE DOCUMENT OUTLINE WINDOW

Show nested layout of elements in XAML

BUILDING A CUSTOM XAML EDITOR

WPF API supports ability to load, parse, and save XAML descriptions programmatically. 

Can be useful. Assume have 5 different XAML files that describe look and feel of a window type. As long as names or each control
and any necessary event handlers are identifical within each file, it is possible to dynamically apply "skins" to windows. 

Interacting with XAMl at runtime revolves around the XamlReader and XamlWriter types, both defined within System.Windows.Markup namespace

<Window x:Class="MyXamlPad.MainWindow"
xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
Title="My Custom XAML Editor"
Height="338" Width="1041"
Loaded="Window_Loaded" Closed="Window_Closed"
WindowStartupLocation="CenterScreen">
 
<!-- You will use a DockPanel, not a Grid -->
<DockPanel LastChildFill="True" >
<!-- This button will launch a window with defined XAML -->
<Button DockPanel.Dock="Top" Name = "btnViewXaml" Width="100" Height="40"
Content ="View Xaml" Click="btnViewXaml_Click" />
 
<!-- This will be the area to type within -->
<TextBox AcceptsReturn ="True" Name ="txtXamlData"
FontSize ="14" Background="Black" Foreground="Yellow"
BorderBrush ="Blue" VerticalScrollBarVisibility="Auto"
AcceptsTab="True"/>
</DockPanel>
</Window>

IMPLEMENTING THE LOADED EVENT

Loaded event of main window is in charge of determining whether there is currently a file named YourXaml.xaml in folder containing the 
application. If file does exist you will read in the data and place it into the TextBox on the main window. If not, you will fill the 
TextBox ith an initial default XAML description of an empty window. 
